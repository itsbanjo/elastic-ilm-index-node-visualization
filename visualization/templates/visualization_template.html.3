<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elasticsearch Cluster Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #chart {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-top: 20px;
        }
        .node {
            cursor: pointer;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1px;
        }
        .rolling-link {
            fill: none;
            stroke: #404080;
            stroke-width: 2px;
            stroke-dasharray: 5, 5;
        }
        .label {
            font-size: 12px;
            font-weight: bold;
        }
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 8px;
            font: 12px sans-serif;
            background: #f0f0f0;
            border: 1px solid #999;
            border-radius: 4px;
            pointer-events: none;
        }
        .utilization-bar {
            fill: #4CAF50;
        }
        .utilization-background {
            fill: #e0e0e0;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            left: 10px;
        }
        .zoom-controls button {
            font-size: 16px;
            margin-right: 5px;
        }
        #patternFilter {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Elasticsearch Cluster Visualization</h1>
    <div class="zoom-controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">-</button>
        <button id="reset-zoom">Reset</button>
    </div>
    <select id="patternFilter">
        <option value="all">All Patterns</option>
    </select>
    <div id="chart"></div>

    <script>
        const data = {{ CLUSTER_DATA }};
        const rollingIndices = {{ ROLLING_INDICES }};
        const rollingIndicesSize = {{ ROLLING_INDICES_SIZE }};

        // Set up dimensions
        const width = 1800;
        const height = 900;
        const margin = {top: 20, right: 300, bottom: 30, left: 120};
        const nodeSpacing = 100;  // Fixed spacing between nodes

        // Create SVG
        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Create zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", zoomed);

        svg.call(zoom);

        function zoomed(event) {
            g.attr("transform", event.transform);
        }

        // Zoom control buttons
        d3.select("#zoom-in").on("click", () => {
            svg.transition().call(zoom.scaleBy, 1.5);
        });

        d3.select("#zoom-out").on("click", () => {
            svg.transition().call(zoom.scaleBy, 0.75);
        });

        d3.select("#reset-zoom").on("click", () => {
            svg.transition().call(zoom.transform, d3.zoomIdentity);
        });

        // Populate pattern filter dropdown
        const patternFilter = d3.select("#patternFilter");
        Object.keys(rollingIndices).forEach(pattern => {
            patternFilter.append("option")
                .attr("value", pattern)
                .text(pattern);
        });

        // Filter and update visualization based on selected pattern
        patternFilter.on("change", function() {
            const selectedPattern = this.value;
            updateVisualization(selectedPattern);
        });

        function updateVisualization(selectedPattern) {
            // Clear existing visualization
            g.selectAll("*").remove();

            // Filter data based on selected pattern
            const filteredData = filterData(data, selectedPattern);

            // Create hierarchical layout
            const root = d3.hierarchy(filteredData);
            const treeLayout = d3.tree().size([height, width - 600]);
            
            // Custom layout function to ensure fixed spacing
            function customLayout(root) {
                treeLayout(root);
                root.eachBefore(node => {
                    node.y = node.depth * 200;  // Fixed horizontal spacing
                    if (node.parent) {
                        node.x = node.parent.x + (node.parent.children.indexOf(node) - (node.parent.children.length - 1) / 2) * nodeSpacing;
                    }
                });
                return root;
            }

            customLayout(root);

            // Create links
            g.selectAll(".link")
                .data(root.links())
                .enter().append("path")
                .attr("class", "link")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y)
                    .y(d => d.x));

            // Create nodes
            const node = g.selectAll(".node")
                .data(root.descendants())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.y},${d.x})`);

            // Add circles to nodes
            node.append("circle")
                .attr("r", 10)
                .style("fill", d => {
                    if (d.depth === 0) return "#69b3a2";
                    if (d.depth === 1) return "#404080";
                    if (d.depth === 2) {
                        return d.parent.data.name === "Hot Nodes" ? "#ff4136" :
                               d.parent.data.name === "Warm Nodes" ? "#ff851b" :
                               d.parent.data.name === "Cold Nodes" ? "#0074d9" :
                               "#b10dc9";
                    }
                    return d.data.rollingIndex ? "#ffd700" : "#aaa";
                });

            // Add labels to nodes
            node.append("text")
                .attr("dy", ".35em")
                .attr("x", d => d.children ? -13 : 13)
                .style("text-anchor", d => d.children ? "end" : "start")
                .text(d => d.data.name)
                .style("font-size", d => d.depth === 3 ? "10px" : "12px");

            // Add utilization bars for individual nodes
            node.filter(d => d.depth === 2)
                .append("g")
                .attr("transform", "translate(20, -30)")
                .call(g => {
                    const barWidth = 60;
                    const barHeight = 5;
                    const metrics = [
                        {name: "CPU", key: "cpuUsage", color: "#4CAF50"},
                        {name: "Memory", key: "memoryUsage", color: "#2196F3"},
                        {name: "Disk", key: "diskUsage", color: "#FFC107"}
                    ];

                    metrics.forEach((metric, i) => {
                        g.append("rect")
                            .attr("y", i * (barHeight + 2))
                            .attr("width", barWidth)
                            .attr("height", barHeight)
                            .attr("class", "utilization-background");

                        g.append("rect")
                            .attr("y", i * (barHeight + 2))
                            .attr("width", d => (d.data[metric.key] / 100) * barWidth)
                            .attr("height", barHeight)
                            .attr("fill", metric.color);

                        g.append("text")
                            .attr("x", barWidth + 5)
                            .attr("y", i * (barHeight + 2) + barHeight)
                            .text(d => `${metric.name}: ${d.data[metric.key]}%`)
                            .style("font-size", "8px");
                    });
                });

            // Add rolling index nodes and links
            if (selectedPattern === "all") {
                Object.entries(rollingIndices).forEach(([name, indices], i) => {
                    const x = width - 250;
                    const y = (i + 1) * (height / (Object.keys(rollingIndices).length + 1));

                    // Add rolling index node
                    g.append("circle")
                        .attr("cx", x)
                        .attr("cy", y)
                        .attr("r", 7)
                        .style("fill", "#404080");

                    g.append("text")
                        .attr("x", x + 15)
                        .attr("y", y)
                        .attr("dy", ".35em")
                        .text(`${name} (${rollingIndicesSize[name]} MB)`)
                        .style("font-size", "12px")
                        .style("font-weight", "bold");

                    // Add links to indices
                    root.descendants().forEach(node => {
                        if (indices.includes(node.data.name)) {
                            g.append("path")
                                .attr("class", "rolling-link")
                                .attr("d", d3.linkHorizontal()
                                    .x(d => d.y)
                                    .y(d => d.x)
                                    ({
                                        source: {x: y, y: x},
                                        target: {x: node.x, y: node.y}
                                    }));
                        }
                    });
                });
            } else {
                const indices = rollingIndices[selectedPattern];
                const x = width - 250;
                const y = height / 2;

                // Add rolling index node
                g.append("circle")
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", 7)
                    .style("fill", "#404080");

                g.append("text")
                    .attr("x", x + 15)
                    .attr("y", y)
                    .attr("dy", ".35em")
                    .text(`${selectedPattern} (${rollingIndicesSize[selectedPattern]} MB)`)
                    .style("font-size", "12px")
                    .style("font-weight", "bold");

                // Add links to indices
                root.descendants().forEach(node => {
                    if (indices.includes(node.data.name)) {
                        g.append("path")
                            .attr("class", "rolling-link")
                            .attr("d", d3.linkHorizontal()
                                .x(d => d.y)
                                .y(d => d.x)
                                ({
                                    source: {x: y, y: x},
                                    target: {x: node.x, y: node.y}
                                }));
                    }
                });
            }

            // Add tooltips
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            node.on("mouseover", function(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                let tooltipContent = `${d.data.name}<br/>`;
                if (d.data.size) tooltipContent += `Size: ${d.data.size} MB<br/>`;
                if (d.data.cpuUsage !== undefined) tooltipContent += `CPU Usage: ${d.data.cpuUsage}%<br/>`;
                if (d.data.cpuFree !== undefined) tooltipContent += `CPU Free: ${d.data.cpuFree}%<br/>`;
                if (d.data.memoryUsage !== undefined) tooltipContent += `Memory Usage: ${d.data.memoryUsage}%<br/>`;
                if (d.data.memoryTotal !== undefined) tooltipContent += `Memory Total: ${(d.data.memoryTotal / (1024 * 1024 * 1024)).toFixed(2)} GB<br/>`;
                if (d.data.diskUsage !== undefined) tooltipContent += `Disk Usage: ${d.data.diskUsage}%<br/>`;
                if (d.data.diskTotal !== undefined) tooltipContent += `Disk Total: ${(d.data.diskTotal / (1024 * 1024 * 1024)).toFixed(2)} GB<br/>`;
                
                if (d.data.memoryDetails) {
                    const memDetails = d.data.memoryDetails;
                    tooltipContent += `JVM Heap: ${(memDetails.jvmHeap / (1024 * 1024)).toFixed(2)} MB<br/>`;
                    tooltipContent += `Field Data Cache: ${(memDetails.fieldDataCache / (1024 * 1024)).toFixed(2)} MB<br/>`;
                    tooltipContent += `Query Cache: ${(memDetails.queryCache / (1024 * 1024)).toFixed(2)} MB<br/>`;
                    tooltipContent += `Segment Memory: ${(memDetails.segmentMemory / (1024 * 1024)).toFixed(2)} MB<br/>`;
                }

                if (d.data.rollingIndex) {
                    tooltipContent += `Rolling Index: ${d.data.rollingIndex}<br/>`;
                    tooltipContent += `Total Size: ${rollingIndicesSize[d.data.rollingIndex]} MB<br/>`;
                }

                tooltip.html(tooltipContent)
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });
        }

        function filterData(data, pattern) {
            if (pattern === "all") return data;

            const filteredData = JSON.parse(JSON.stringify(data)); // Deep clone
            filteredData.children.forEach(nodeType => {
                nodeType.children.forEach(node => {
                    node.children = node.children.filter(index => 
                        rollingIndices[pattern].includes(index.name)
                    );
                });
                nodeType.children = nodeType.children.filter(node => node.children.length > 0);
            });
            filteredData.children = filteredData.children.filter(nodeType => nodeType.children.length > 0);
            return filteredData;
        }

        // Initial visualization
        updateVisualization("all");
    </script>
</body>
</html>
